---
layout: post
title: Unit testing Akka.NET actors and MEF
date: '2015-09-13T00:51:00.001-07:00'
author: Usein Mambediiev
tags:
- unit testing
- MEF
- Akka.NET
modified_time: '2015-09-13T00:54:52.365-07:00'
blogger_id: tag:blogger.com,1999:blog-2780778380464436954.post-6744545586333783338
blogger_orig_url: https://usemam.blogspot.com/2015/09/unit-testing-akkanet-actors-and-mef.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">As you maybe realized from the title, I will talk about <a href="http://getkka.net/">Akka.NET</a>,&nbsp;a .NET port of famous <a href="http://akka.io/">Akka</a> framework, combined with <a href="https://mef.codeplex.com/">MEF</a>&nbsp;dependency injection library, and how you can use mocks (I will use <a href="https://github.com/Moq/moq4">Moq</a> to leverage mocking power) to unit-test Akka.Net actors.<br /><br /><a name='more'></a>So, let's say we have some actor class with external dependency and this actor needs to be tested.<br /><pre class="brush: csharp">using System.Composition;<br /><br />using Akka.Actor;<br /><br />namespace AkkaMefTest<br />{<br />    [Export]<br />    public class MyActor : ReceiveActor<br />    {<br />        [Import]<br />        public IDependency Dependency { get; set; }<br /><br />        public MyActor()<br />        {<br />            this.Receive&lt;TestMessage&gt;(message =&gt; this.ProcessMessage(message));<br />        }<br /><br />        private void ProcessMessage(TestMessage message)<br />        {<br />            // process message in some way here<br />            // ...<br />            this.Dependency.DoSomething();<br />        }<br /><br />        public class TestMessage<br />        {<br />            public string Message { get; private set; }<br /><br />            public TestMessage(string message)<br />            {<br />                this.Message = message;<br />            }<br />        }<br />    }<br />}<br /><br /></pre>As you can see, the actor is pretty simple - it handles only one message and while doing this, calls <i>Dependency.DoSomething()</i>&nbsp;method. The <i>IDependency </i>interface itself contains only one method:<br /><pre class="brush: csharp">namespace AkkaMefTest<br />{<br />    public interface IDependency<br />    {<br />        void DoSomething();<br />    }<br />}<br /></pre><br />Ok. Now when we have functional code, we need to figure out how to unit-test it.<br />Let's write down things we will need to do in order to write unit test for our actor:<br /><br /><ol style="text-align: left;"><li>Testing framework. Akka.NET supports a lot of famous testing frameworks. I personally prefer NUnit.</li><li>Mock external dependency - this is really easy actually. Moq library will help us to do it.</li><li>Because we are using dependency injection (MEF) we need find a way how to inject our mock into actor. This will covered lately.</li></ol><div>Keeping this 3 things in mind, let's create a test for our actor.</div><div><br /><pre class="brush: csharp">using Akka.Actor;<br />using Akka.DI.Core;<br />using Akka.TestKit.NUnit;<br /><br />using Moq;<br /><br />using NUnit.Framework;<br /><br />namespace AkkaMefTest<br />{<br />    [TestFixture]<br />    public class Tests : TestKit<br />    {<br />        protected IActorRef MyActor { get; private set; }<br /><br />        protected Mock&lt;IDependency&gt; DependencyMock { get; private set; }<br /><br />        [SetUp]<br />        public void Initialize()<br />        {<br />            this.DependencyMock = new Mock&lt;IDependency&gt;();<br /><br />            this.MyActor = this.Sys.ActorOf(this.Sys.DI().Props&lt;MyActor&gt;(), "test");<br />        }<br /><br />        [Test]<br />        public void Send_test_message_and_check_dependency_was_called()<br />        {<br />            // arrange<br />            var finished = this.CreateTestBarrier(count: 2);<br />            // act<br />            this.MyActor.Tell(new MyActor.TestMessage("This is test message."));<br />            // assert<br />            finished.Await();<br />            this.DependencyMock.Verify(dep =&gt; dep.DoSomething(), Times.Once);<br />        }<br />    }<br />}<br /></pre><br />This code is almost correct. Why almost? Despite that it will compile successfully, it won't work and test will fail because we are not injecting <i>DependencyMock</i> into <i>MyActor </i>instance. However, we can easily oversome this by creating special dependency resolver. <br /><pre class="brush: csharp">using System;<br />using System.Collections.Concurrent;<br />using System.Composition;<br />using System.Linq;<br />using System.Reflection;<br /><br />using Akka.Actor;<br />using Akka.DI.Core;<br />using Akka.TestKit.NUnit;<br /><br />using Moq;<br /><br />namespace AkkaMefTest<br />{<br />    public class TestDependencyResolver : IDependencyResolver<br />    {<br />        private readonly ActorSystem _system;<br /><br />        private readonly TestKit _test;<br /><br />        private readonly ConcurrentDictionary&lt;string, Type&gt; _typeCache;<br /><br />        public TestDependencyResolver(ActorSystem system, TestKit test)<br />        {<br />            this._test = test;<br />            this._typeCache = new ConcurrentDictionary&lt;string, Type&gt;(StringComparer.InvariantCultureIgnoreCase);<br />            this._system = system;<br />            this._system.AddDependencyResolver(this);<br />        }<br /><br />        public Props Create&lt;TActor&gt;() where TActor : ActorBase<br />        {<br />            return this._system.GetExtension&lt;DIExt&gt;().Props(typeof(TActor));<br />        }<br /><br />        public Func&lt;ActorBase&gt; CreateActorFactory(Type actorType)<br />        {<br />            return () =&gt; this.InitializeActorWithImports(actorType);<br />        }<br /><br />        public Type GetType(string actorName)<br />        {<br />            this._typeCache.TryAdd(actorName, actorName.GetTypeValue());<br /><br />            return this._typeCache[actorName];<br />        }<br /><br />        public void Release(ActorBase actor)<br />        {<br />            // do nothing<br />        }<br /><br />        private ActorBase InitializeActorWithImports(Type actorType)<br />        {<br />            PropertyInfo[] mockProperties =<br />                this._test.GetType()<br />                    .GetProperties(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.Instance)<br />                    .Where(p =&gt; p.PropertyType.IsGenericType &amp;&amp; p.PropertyType.GetGenericTypeDefinition() == typeof(Mock&lt;&gt;))<br />                    .ToArray();<br />            PropertyInfo[] importProperties =<br />                actorType.GetProperties(BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.SetProperty | BindingFlags.Instance)<br />                         .Where(p =&gt; p.GetCustomAttribute&lt;ImportAttribute&gt;() != null)<br />                         .ToArray();<br />            object actor = Activator.CreateInstance(actorType);<br />            foreach (PropertyInfo importProperty in importProperties)<br />            {<br />                PropertyInfo property = importProperty;<br />                PropertyInfo mockProperty = mockProperties.SingleOrDefault(<br />                    p =&gt; p.PropertyType.GetGenericArguments().Single() == property.PropertyType);<br />                if (null == mockProperty)<br />                {<br />                    throw new Exception(string.Format("Can't find mock for import [{0}]", importProperty.Name));<br />                }<br /><br />                object importValue = ((Mock)mockProperty.GetValue(this._test)).Object;<br />                importProperty.SetValue(actor, importValue);<br />            }<br /><br />            return (ActorBase)actor;<br />        }<br />    }<br />}</pre><br />This dependency resolver searches for mock instances in test class and injects them into instance of an actor under test. Quite simple, isn't it? Let's finish our test class by creating dependency resolver's instance. <br /><pre class="brush: csharp">        ...<br />        [SetUp]<br />        public void Initialize()<br />        {<br />            this.DependencyMock = new Mock&lt;IDependency&gt;();<br /><br />            var dependencyResolver = new TestDependencyResolver(this.Sys, this);<br />            this.MyActor = this.Sys.ActorOf(this.Sys.DI().Props&lt;MyActor&gt;(), "test");<br />        }<br /></pre><br />Compile and run our test - works like a charm! </div></div>