---
layout: post
title: Implementing Priority Queue with JavaScript
date: '2020-10-23T16:00:00.002-07:00'
author: Usein Mambediiev
tags:
- algorithms
- javascript
- data structures
modified_time: '2020-10-23T21:22:45.795-07:00'
blogger_id: tag:blogger.com,1999:blog-2780778380464436954.post-8238560408059666943
blogger_orig_url: https://usemam.blogspot.com/2020/10/implementing-priority-queue-with.html
---

<p>Recently I had an opportunity of solving <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank">one of more famous</a> algorithmic problems using JavaScript. One of the approaches to this problem is to use <a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank">Priority Queue</a> data structure to keep track of most frequent items. Unfortunately, JavaScript doesn't have standard implementation for such data structure.</p><p>So - let's build one.</p><span><a name='more'></a></span><p>The idea behind a priority queue (and binary heap as well) is simple - maintain elements in an array, while mimicking a behavior of <b>complete</b> binary tree. In other words - every tree level, except possibly the last one, is completely filled, and all nodes on the last level are located as far left as possible.</p><p>Now, what this structure gives us in terms of time complexity when we want to add to a queue, or remove from it?</p><p>Let's take a look at add operation first.<br />When we add new item to a queue, it is appended to an end of an array. Because we want highest priority element to be the first in our array, we need to push our new element to a highest possible level of our complete binary tree. How it's done? We know the array index of newly added element, let's call it <i><b>'i'</b>.</i>&nbsp;The index of a parent element equals <i><b>(i-1)/2</b></i>&nbsp;(it's a complete binary tree after all). Now, we need to compare parent's and child's priorities, and swap those if child's priority is higher than parent's. This process of comparing and swapping continues until new element either becomes a root of our tree (<i>i = 0</i>) or it hits a parent with higher priority. Overall, this "sifting up" process takes <i><b>O(log N)</b></i> time because <i>'i'</i> index is split in half on each iteration.</p><p>Queue's remove operation is actually slightly more complicated.<br />The nature of adding new item into the queue guarantees that first element of underlying array is the element that has the highest priority. This first element is the result that's returned.<br />Now, when result is extracted from the queue, how to update our tree to maintain highest priority item on top? For this we can move last array element to '0' index (<i>i = 0</i>) and perform steps opposite to those of adding - compare root with left (<i><b>i*2 + 1</b></i>) and right (<i><b>i*2 + 2</b></i>) subtrees and swap root with one of them if root's priority is less than subtree's priority. Repeat until we either run out of subtrees (end of the array) or root has higher priority than its children. This "sifting down" takes <i><b>O(log N)</b></i> time as well.</p><p>So, how exactly all of this maps to an actual JavaScript code?<br />For that I've put a simple class that implements priority queue while expecting from queued objects to expose <b>.priority</b> property (duck-typing for the win!):<br /><script src="https://gist.github.com/usemam/2a82ff2fa33872f4bc6510bc13139e86.js"></script></p>