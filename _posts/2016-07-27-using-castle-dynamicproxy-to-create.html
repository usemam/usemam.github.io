---
layout: post
title: Using Castle DynamicProxy to create... dynamic proxy!
date: '2016-07-27T10:21:00.001-07:00'
author: Usein Mambediiev
tags:
- DynamicProxy
- MEF
modified_time: '2016-07-31T02:10:58.335-07:00'
blogger_id: tag:blogger.com,1999:blog-2780778380464436954.post-6056120007184196927
blogger_orig_url: https://usemam.blogspot.com/2016/07/using-castle-dynamicproxy-to-create.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">The subject of this post is not really new I guess, but since I myself stumbled upon such puzzle, I decided to blog about my own experience.<br /><br /><a name='more'></a>Let's say that you have some project with a back-end accessible through WCF-service(s) facade, and a client app written in C#. Let me add to this that you also have some business logic encapsulated in a form of a special service class that implements special interface. Moreover, you share that interface across your applications.<br /><pre class="brush: csharp">public interface IUserService<br />{<br />&nbsp; &nbsp; AuthenticatedUser Authenticate(string login, string password);<br /><br />&nbsp; &nbsp; void ChangeUserOffice(int userId, int officeId);<br />}<br /><br />[Export(typeof(IUserService))]<br />public class BackendUserService : IUserService<br />{<br />&nbsp; &nbsp; public AuthenticatedUser Authenticate(string login, string password)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // user authentication logic<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public void ChangeUserOffice(int userId, int officeId)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // office change logic<br />&nbsp; &nbsp; }<br />}<br /></pre>That's basically what you have on your back-end: service with business logic exposed to clients through WCF facade. Let's go to the client.<br /><pre class="brush: csharp">[Export(typeof(IUserService))]<br />public class ClientUserService : IUserService<br />{<br />&nbsp; &nbsp; public AuthenticatedUser Authenticate(string login, string password)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // call WCF facade<br />&nbsp; &nbsp; &nbsp; &nbsp; using (var serviceClient = new UserServiceClient())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return serviceClient.AuthenticateUser(login, password);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public void ChangeUserOffice(int userId, int officeId)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // you don't need this method on a client, you've simply left it not implemented<br />&nbsp; &nbsp; &nbsp; &nbsp; throw new NotImplementedException();<br />&nbsp; &nbsp; }<br />}<br /></pre><u>N.B. I'm using MEF 2 (System.Compostion.*) as a DI container, that's why I added <i>Export</i> attribute for both IUserService implementations. This detail will appear to be quite important later.</u><br /><br />This not implemented <i>ChangeUserOffice</i> method doesn't look neat, does it?<br /><br />Recently, I had the same, even worse situation - interface was much richer, with around 10 methods, and only 3 of them were used on a client.<br />My first try to tackle with this problem involved generating (using T4 template) special dummy class that consisted of virtual not implemented methods. This class was further inherited by client's service and selected methods were overridden.<br />At first sight, issue was solved. However, further experience proved that developers constantly forget about regenerating T4 template, after changing service's interface, which leads to compile-time errors (broken CI builds, anger, frustration, etc.).<br />The situation was no good, so I decided to implement different approach based on dynamic method dispatching. <a href="http://www.castleproject.org/projects/dynamicproxy/" target="_blank">Castle DynamicProxy</a> looked like an ideal library for that purpose.<br />First of all I needed some base class to do the basic dispatching work. After some time I've come up with this one:<br /><pre class="brush: csharp">namespace DynamicServiceProxy<br />{<br />&nbsp; &nbsp; public class Proxy&lt;TServiceInterface&gt; : IInterceptor<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; public Proxy()<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var generator = new ProxyGenerator();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.Interface =<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (TServiceInterface) generator.CreateInterfaceProxyWithoutTarget(typeof (TServiceInterface), this);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public TServiceInterface Interface { get; private set; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; void IInterceptor.Intercept(IInvocation invocation)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var proxyType = this.GetType();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var argTypes = this.GetArgumentsTypes(invocation.Arguments);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var method = proxyType.GetMethod(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invocation.Method.Name, BindingFlags.Public | BindingFlags.Instance,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null, argTypes, null);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (method != null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invocation.ReturnValue = method.Invoke(this, invocation.Arguments);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // No match was found for required method<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NotImplementedException(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $"No match was found for method {invocation.Method.Name}.");<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private Type[] GetArgumentsTypes(object[] args)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var argTypes = new Type[args.GetLength(0)];<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var index = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var arg in args)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argTypes[index] = arg.GetType();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return argTypes;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />}<br /></pre><i>Interface</i> property here is an actual interceptor, that I will expose to a proxy users. As you can see, from IInterceptor.Intercept method implementation, it will process every method invocation and, if respective method is present in concrete derived class, invoke it. Otherwise,&nbsp;<i>NotImplementedException</i> will be thrown.<br />Alright, we have the base class, now it's time to use it. Let's look at new <i>ClientUserService</i> class:<br /><pre class="brush: csharp">public class ClientUserService : Proxy&lt;IUserService&gt;<br />{<br />&nbsp; &nbsp; public AuthenticatedUser Authenticate(string login, string password)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // call WCF facade<br />&nbsp; &nbsp; &nbsp; &nbsp; using (var serviceClient = new UserServiceClient())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return serviceClient.AuthenticateUser(login, password);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />}<br /></pre>That's it - ready for use proxy, that use DynamicProxy technology under the hood.<br />However, if you noticed, I'm no longer using <i>Export</i> attribute. That's because MEF will throw an exception, if export this class straightforward, using just attribute. To overcome this, I will need one more thing - using MEF's special <i><a href="https://msdn.microsoft.com/en-us/library/system.composition.convention.conventionbuilder(v=vs.110).aspx" target="_blank">ConventionBuilder</a></i> class, I can register proxy's <i>Interface</i> property as an export:<br /><pre class="brush: csharp">public void UpdateConvetion(ConventionBuilder builder)<br />{<br />&nbsp; &nbsp; builder.ForType&lt;ClientUserService&gt;()<br />&nbsp; &nbsp; &nbsp; &nbsp; .ExportProperty&lt;IUserService&gt;(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x =&gt; x.Interface,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b =&gt; b.AsContractType&lt;IUserService&gt;());<br />}<br /></pre>Done. Now I can import my proxy just by adding <i>Import</i> attribute to any appropriate property.<br /><br />To summarize, let me add that I made a transition from compile-time solution to a runtime one, with all possible drawbacks - no compile-time checks for conformity with interface declarations. To some extent, this check can be replaced by special unit-test - I will show how to do such testing in my next post. Thank you and stay tuned.<br /><br />UPD: Code for this and <a href="http://usemam.blogspot.com/2016/07/make-sure-your-dynamic-proxy-is-on-same.html" target="_blank">next article</a> is on <a href="https://github.com/usemam/DynamicServiceProxy" target="_blank">GitHub</a>.</div>