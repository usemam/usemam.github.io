---
layout: post
title: Make sure your dynamic proxy is on the same page with your interface
date: '2016-07-30T06:25:00.000-07:00'
author: Usein Mambediiev
tags:
- DynamicProxy
- reflection
- unit testing
modified_time: '2016-07-31T02:12:20.727-07:00'
blogger_id: tag:blogger.com,1999:blog-2780778380464436954.post-1260848132762769716
blogger_orig_url: https://usemam.blogspot.com/2016/07/make-sure-your-dynamic-proxy-is-on-same.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">In my <a href="http://usemam.blogspot.com/2016/07/using-castle-dynamicproxy-to-create.html" target="_blank">previous post</a> I was talking about how to create dynamic proxy using <a href="http://www.castleproject.org/projects/dynamicproxy/" target="_blank">Castle DynamicProxy</a>. Now, I want to shed some light on how to make sure that your proxy class complies with your interface, using special unit-tests.<br /><br /><a name='more'></a>First of all, let's take a step back and recall our proxy class and an interface:<br /><pre class="brush: csharp">public interface IUserService<br />{<br />    AuthenticatedUser Authenticate(string login, string password);<br /><br />    void ChangeUserOffice(int userId, int officeId);<br />}<br /><br />public class ClientUserService : Proxy&lt;IUserService&gt;<br />{<br />    public AuthenticatedUser Authenticate(string login, string password)<br />    {<br />        // do something<br />        return new AuthenticatedUser();<br />    }<br />}<br /></pre><br />The most obvious tests we can have for <i>ClientUserService </i>are those that show that it's working as expected:<br /><pre class="brush: csharp">[TestFixture]<br />public class InvocationTests<br />{<br />    private IUserService _service;<br /><br />    [OneTimeSetUp]<br />    public void Setup()<br />    {<br />        var proxy = new ClientUserService();<br />        this._service = proxy.Interface;<br />    }<br /><br />    [Test]<br />    public void Implemented_method_works_fine()<br />    {<br />        var result = this._service.Authenticate("test", "test");<br />        Assert.IsNotNull(result);<br />    }<br /><br />    [Test]<br />    public void Not_implemented_method_throws_exception()<br />    {<br />        const int userId = 1;<br />        const int officeId = 2;<br />        Assert.Throws&lt;NotImplementedException&gt;(<br />            () =&gt; this._service.ChangeUserOffice(userId, officeId));<br />    }<br />}<br /></pre>As expected - tests above working just fine. However, they do not provide much value for us. Why? If we have just one interface with two methods, these tests are totally appropriate. But what if we have 5 interfaces (with a bunch of methods each) to proxy? How much effort we will need to support tests for each method in every interface we have? Let's create something smarter.<br /><br />My plan is to create some comparison tests, using reflection. I assume that public proxy methods should have corresponding declarations defined in the interface, conforming to following rules:<br /><br /><ol style="text-align: left;"><li>Methods match by name.</li><li>Methods match by parameters.</li><li>Methods match by returning type.</li></ol><div>I will implement these rules as separate test-cases. But before, I need to create essential helper methods:</div><div><pre class="brush: csharp">private static IEnumerable&lt;MethodInfo&gt; GetTypeMethods&lt;T&gt;()<br />{<br />    return typeof(T).GetMethods(<br />        BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);<br />}<br /><br />private static bool MethodsMatchByParameters(MethodInfo first, MethodInfo second)<br />{<br />    var firstParams = first.GetParameters().OrderBy(x =&gt; x.Position).ToArray();<br />    var secondParams = second.GetParameters().OrderBy(x =&gt; x.Position).ToArray();<br />    if (firstParams.Length != secondParams.Length)<br />    {<br />        return false;<br />    }<br /><br />    var zippedParams =<br />        firstParams.Zip(secondParams, (f, s) =&gt; new {First = f, Second = s});<br />    return zippedParams.All(x =&gt; x.First.ParameterType == x.Second.ParameterType);<br />}<br /></pre></div><div>First one returns all public methods defined by the type. The second will tell if two methods possess same parameter lists.</div><div><br /></div><div>First rule from the list is the most simple to implement:</div><div><pre class="brush: csharp">[Test]<br />public void Proxy_has_methods_with_correct_names()<br />{<br />    var contractMethodNames =<br />        GetTypeMethods&lt;IUserService&gt;().Select(x =&gt; x.Name).ToArray();<br />    var proxyMethodNames =<br />        GetTypeMethods&lt;ClientUserService&gt;().Select(x =&gt; x.Name);<br />    var notContractProxyMethods =<br />        proxyMethodNames.Where(x =&gt; !contractMethodNames.Contains(x)).ToArray();<br />    Assert.IsTrue(<br />        notContractProxyMethods.Length == 0,<br />        $"Following methods do not belong to an interface: {string.Join(",", notContractProxyMethods)}");<br />}<br /></pre></div><div>Then goes "match by parameters" case:</div><div><pre class="brush: csharp">[Test]<br />public void Proxy_methods_have_correct_parameters()<br />{<br />    var contractMethods = GetTypeMethods&lt;IUserService&gt;();<br />    var proxyMethods = GetTypeMethods&lt;ClientUserService&gt;();<br />    var proxyMethodToContractMethodsMap =<br />        proxyMethods.ToDictionary(<br />            x =&gt; x,<br />            x =&gt; contractMethods.Where(m =&gt; x.Name == m.Name).ToList());<br />    var proxyMethodsWithNotMatchingParams =<br />        proxyMethodToContractMethodsMap<br />            .Where(p =&gt; p.Value.All(x =&gt; !MethodsMatchByParameters(p.Key, x)))<br />            .Select(p =&gt; p.Key.Name)<br />            .ToArray();<br />     Assert.IsTrue(<br />         proxyMethodsWithNotMatchingParams.Length == 0,<br />         $"Following methods have incorrect list of parameters: {string.Join(",", proxyMethodsWithNotMatchingParams)}");<br />}<br /></pre></div><div>And finally, matching returning types:</div><div><pre class="brush: csharp">[Test]<br />public void Proxy_methods_have_correct_return_types()<br />{<br />    var contractMethods = GetTypeMethods&lt;IUserService&gt;();<br />    var proxyMethods = GetTypeMethods&lt;ClientUserService&gt;();<br />    var proxyMethodToContractMethodsMap =<br />        proxyMethods.ToDictionary(<br />            x =&gt; x,<br />            x =&gt; contractMethods.Where(m =&gt; x.Name == m.Name).ToList());<br />    var proxyMethodsWithNotMatchingReturnTypes =<br />        proxyMethodToContractMethodsMap<br />            .SelectMany(<br />                 p =&gt; p.Value.Where(x =&gt; MethodsMatchByParameters(p.Key, x))<br />                          .Select(x =&gt; new {First = p.Key, Second = x}))<br />            .Where(x =&gt; x.First.ReturnType != x.Second.ReturnType)<br />            .Select(x =&gt; x.First.Name)<br />            .ToArray();<br />    Assert.IsTrue(<br />        proxyMethodsWithNotMatchingReturnTypes.Length == 0,<br />        $"Following methods have incorrect return types: {string.Join(",", proxyMethodsWithNotMatchingReturnTypes)}");<br />}<br /></pre></div><br /><div>Here we go. All three test-cases can be checked easily for validity.</div><div>What further can be done to these tests? In case you have more than one proxy, you can make <a href="http://nunit.org/index.php?p=testFixture&amp;r=2.5" target="_blank">generic testfixture</a> and parameterize it with as many proxy types as you wish, thus saving yourself time on writing code.<br /><br />UPD: Code for this and <a href="http://usemam.blogspot.com/2016/07/using-castle-dynamicproxy-to-create.html" target="_blank">previous article</a> is on <a href="https://github.com/usemam/DynamicServiceProxy" target="_blank">GitHub</a>.</div></div>